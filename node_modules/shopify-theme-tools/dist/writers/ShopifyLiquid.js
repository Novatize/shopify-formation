"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const strip_json_comments_1 = __importDefault(require("strip-json-comments"));
const defaultSectionSettings_1 = require("../constants/defaultSectionSettings");
const ShopifySectionSettingFactory_1 = require("../factories/ShopifySectionSettingFactory");
class ShopifyLiquid {
    constructor(prefix, sectionName) {
        this.processDir = process.cwd();
        this.prefix = prefix;
        this.sectionName = sectionName;
        this.destinationPath = path_1.default.join(this.processDir, "sections", `${this.prefix.length > 0 ? this.prefix + "-" : ""}${this.sectionName}.liquid`);
        this.liquid = "";
    }
    from(sectionName) {
        const sourcePath = path_1.default.join(this.processDir, "sections", sectionName + ".liquid");
        if (!fs_1.default.existsSync(sourcePath)) {
            throw new Error(`Section file ${this.sectionName} does not exist.`);
        }
        try {
            this.liquid = fs_1.default.readFileSync(sourcePath, "utf-8");
        }
        catch (e) {
            console.log(e);
        }
        return this;
    }
    save() {
        fs_1.default.writeFileSync(this.destinationPath, this.liquid);
        return this;
    }
    addSectionBlocks(sectionBlocks) {
        const { data, matchIndex } = this.getSchema();
        if (data) {
            data.blocks = data.blocks || [];
            for (const block of sectionBlocks) {
                const transPrefix = `t:sections.${this.sectionName}.blocks.${block.type}`;
                data.blocks.push({
                    type: block.type,
                    name: `${transPrefix}.name`,
                    settings: block.settings &&
                        block.settings.map((setting) => {
                            return this.getSectionSettingLiquid(setting.id, setting, `${transPrefix}.settings.${setting.id}`);
                        }),
                });
            }
            this.liquid = this.liquid.slice(0, matchIndex) + "{% schema %}\n";
            this.liquid += JSON.stringify(data, null, 2) + "\n";
            this.liquid += "{% endschema %}\n";
        }
        return this;
    }
    addSectionSettings(sectionSettings) {
        const { data, matchIndex } = this.getSchema();
        if (data) {
            for (const sectionSetting of sectionSettings) {
                const id = sectionSetting.id.replace(/ /g, "_");
                data.settings =
                    data.settings ||
                        [];
                if (data.settings.find((setting) => setting.id === id)) {
                    console.log("\x1b[33m", `Warning: Setting already exists.\n`);
                    return this;
                }
                const transPrefix = `t:sections.${this.sectionName}.settings.${id}`;
                data.settings.push(this.getSectionSettingLiquid(id, sectionSetting, transPrefix));
            }
            this.liquid = this.liquid.slice(0, matchIndex) + "{% schema %}\n";
            this.liquid += JSON.stringify(data, null, 2) + "\n";
            this.liquid += "{% endschema %}\n";
        }
        return this;
    }
    createSection(hasBaseSetting, hasPaddingSetting) {
        const settings = [];
        if (hasPaddingSetting) {
            this.liquid += this.getLiquidPaddingStyle() + "\n\n";
        }
        this.liquid += this.getHtmlString(hasBaseSetting, hasPaddingSetting);
        this.liquid += "\n\n";
        this.liquid += this.getSchemaStringForSectionCreation(hasBaseSetting, hasPaddingSetting);
        return this;
    }
    addStyleSheetImport() {
        const searchString = this.sectionName + ".css' | asset_url | stylesheet_tag }}";
        const cssImportIndex = this.liquid.indexOf(searchString);
        const cssImportString = `{{ '${this.prefix}-${this.sectionName}.css' | asset_url | stylesheet_tag }}`;
        if (cssImportIndex > -1) {
            this.liquid =
                this.liquid.slice(0, cssImportIndex + searchString.length) +
                    "\n" +
                    cssImportString +
                    this.liquid.slice(cssImportIndex + searchString.length);
        }
        else {
            this.liquid = `${cssImportString}\n${this.liquid}`;
        }
        return this;
    }
    addJsImport() {
        this.liquid = `<script src="{{ '${this.prefix}-${this.sectionName}.js' | asset_url }}" defer="defer"></script>\n${this.liquid}`;
        return this;
    }
    scopeStyle() {
        const regex = /{% schema %}([\s\S]*?)"class":\s*"([^"]+)"([\s\S]*?){% endschema %}/;
        const matchs = this.liquid.match(regex);
        if (matchs && matchs[2]) {
            this.liquid = this.liquid.replace(regex, (match, beforeClass, classValue, afterClass) => {
                return `{% schema %}${beforeClass}"class": "${classValue} ${this.prefix}-${this.sectionName}"${afterClass}{% endschema %}`;
            });
        }
        else {
            const search = 'class="';
            const classIndex = this.liquid.indexOf(search) + search.length;
            this.liquid = `${this.liquid.slice(0, classIndex)}${this.prefix}-${this.sectionName} ${this.liquid.slice(classIndex)}`;
        }
        return this;
    }
    prefixTranslation() {
        const snakeSectionName = this.sectionName.replaceAll("-", "_");
        this.liquid = this.liquid.replaceAll(`sections.${snakeSectionName}`, `sections.${this.prefix}_${snakeSectionName}`);
        return this;
    }
    prefixSettingsTranslation() {
        this.liquid = this.liquid.replaceAll("t:sections." + this.sectionName, "t:sections." + this.prefix + "-" + this.sectionName);
        return this;
    }
    indentHtml(html) {
        const indentSize = 2;
        let formatted = "";
        let indentLevel = 0;
        html = html.replace(/\s*(<[^>]+>)\s*/g, "$1"); // Remove unnecessary spaces around tags
        const tokens = html.split(/(?=<)|(?<=>)/g); // Split at opening and closing tags
        tokens.forEach((token) => {
            if (token.match(/^<\/\w/)) {
                indentLevel = Math.max(indentLevel - 1, 0);
            }
            formatted += " ".repeat(indentLevel * indentSize) + token + "\n";
            if (token.match(/^<\w/) && !token.match(/\/>$/)) {
                indentLevel++;
            }
        });
        return formatted.trim();
    }
    validateDestinationNotExists() {
        if (fs_1.default.existsSync(this.destinationPath)) {
            throw new Error(`Prefixed Section file ${this.prefix}-${this.sectionName} already exist`);
        }
        return this;
    }
    validateBlockTypeExists(blockType) {
        const { data } = this.getSchema();
        return data?.blocks?.some((block) => block.type === blockType);
    }
    validateSectionSettingExists(settingId) {
        const { data } = this.getSchema();
        return data?.settings?.some((setting) => setting.id === settingId);
    }
    getSchema() {
        const regex = /{% schema %}([{}":\.\-,\[\]\t\n\r\w\d\s]*){% endschema %}/;
        const matchs = this.liquid.match(regex);
        return matchs && matchs[1]
            ? {
                data: JSON.parse((0, strip_json_comments_1.default)(matchs[1])),
                matchIndex: matchs.index,
            }
            : null;
    }
    getLiquidPaddingStyle() {
        return `\n{%- style -%}
  .section-{{ section.id }}-padding {
    padding-top: {{ section.settings.padding_top | times: 0.75 | round: 0 }}px;
    padding-bottom: {{ section.settings.padding_bottom | times: 0.75 | round: 0 }}px;
  }

  @media screen and (min-width: 750px) {
    .section-{{ section.id }}-padding {
      padding-top: {{ section.settings.padding_top }}px;
      padding-bottom: {{ section.settings.padding_bottom }}px;
    }
  }
{%- endstyle -%}`;
    }
    getSectionSettingDefaultValue(setting, transPrefix) {
        if (!setting.default) {
            return undefined;
        }
        return [
            ShopifySectionSettingFactory_1.ShopifySectionSettingTypes.checkbox,
            ShopifySectionSettingFactory_1.ShopifySectionSettingTypes.number,
            ShopifySectionSettingFactory_1.ShopifySectionSettingTypes.range,
        ].includes(setting.type)
            ? setting.default
            : `${transPrefix}.default`;
    }
    getHtmlString(hasBaseSetting, hasPaddingSetting) {
        let htmlString = `<div ${hasPaddingSetting ? 'class="section-{{ section.id }}-padding"' : ""}>`;
        if (hasBaseSetting) {
            htmlString += "<p>{{ section.settings.heading }}</p>";
            htmlString += "<p>{{ section.settings.content}}</p>";
        }
        htmlString += "</div>";
        return this.indentHtml(htmlString);
    }
    getSchemaStringForSectionCreation(hasBaseSetting, hasPaddingSetting) {
        const settings = [];
        if (hasPaddingSetting) {
            settings.push(defaultSectionSettings_1.paddingTopSetting);
            settings.push(defaultSectionSettings_1.paddingBottomSetting);
        }
        if (hasBaseSetting) {
            settings.push(defaultSectionSettings_1.headingSetting);
            settings.push(defaultSectionSettings_1.contentSetting);
        }
        this.liquid += this.getHtmlString(hasBaseSetting, hasPaddingSetting);
        const schema = {
            name: `t:sections.${this.prefix}-${this.sectionName}.name`,
            tag: "section",
            class: `section ${this.prefix}-${this.sectionName}`,
            settings: settings,
            presets: [
                { name: `t:sections.${this.prefix}-${this.sectionName}.presets.name` },
            ],
        };
        let schemaString = "{% schema %}\n";
        schemaString += JSON.stringify(schema, null, 2) + "\n";
        schemaString += "{% endschema %}\n";
        return schemaString;
    }
    getSectionSettingLiquid(sectionSettingId, sectionSetting, transPrefix) {
        return {
            type: sectionSetting.type,
            id: sectionSettingId,
            label: `${transPrefix}.label`,
            default: this.getSectionSettingDefaultValue(sectionSetting, transPrefix),
            info: sectionSetting.info ? `${transPrefix}.info` : undefined,
            min: sectionSetting.min ? sectionSetting.min : undefined,
            max: sectionSetting.min ? sectionSetting.max : undefined,
            step: sectionSetting.step ? sectionSetting.step : undefined,
            unit: sectionSetting.unit ? sectionSetting.unit : undefined,
            placeholder: sectionSetting.placeholder
                ? `${transPrefix}.placeholder`
                : undefined,
            options: sectionSetting.options
                ? sectionSetting.options.map((option, i) => {
                    return {
                        label: `${transPrefix}.options__${i + 1}.label`,
                        value: option.value,
                    };
                })
                : undefined,
        };
    }
}
exports.default = ShopifyLiquid;
